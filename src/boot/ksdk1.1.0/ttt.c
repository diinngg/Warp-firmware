#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "gpio_pins.h"
#include "SEGGER_RTT.h"
#include "warp.h"

#include "ttt.h"
#include "devSSD1331.h"


// masks for bytes in game[]
// all status info
#define BOX_STAT_MASK  0x70
// whether the move was a cross (1) or nought (0)
#define BOX_CROSS_MASK 0x20
// whether the move was made by the system (1) or player (0)
#define BOX_MINE_MASK  0x10
// box number filled in move
#define BOX_NUM_MASK   0x0F

// colors to display
#define COLOR_GRID COLOR_BLUE
#define COLOR_ME COLOR_RED
#define COLOR_OPP COLOR_GREEN
#define COLOR_ERR COLOR_RED

// space to leave around symbols in boxes
#define BOX_BORDER_OFFSET 2

// delay between printing board lines
#define PRINT_LINE_DELAY 10

// how long to flash error for in ms
#define ERROR_FLASH_MS 500

// whether to learn whilst in 'play' mode
#define PLAY_LEARN false

// learning increment/decrement
#define LEARN_INC 1

// whether the system should go first
#define ME_FIRST

#ifdef ME_FIRST
#define MOVES_EVEN
#else
#define MOVES_ODD
#endif


enum eState
{
    IDLE,
    TRAIN,
    TRAIN_FAST,
    PLAY
} state;

// array to current game
uint8_t game[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
// number of moves made in current game, 9 for no current game
uint8_t numMove = 9;
// offsets of moves made by system in moves[] arrays
uint32_t movesMade[3];

// board ID arrays generated by gen_bytes.py
const uint32_t boards0[] = { 0x1, 0x0 };
const uint32_t boards1[] = { 0x3, 0x1, 0x4, 0x100 };
const uint32_t boards2[] = { 0xC, 0x6, 0x9, 0x12, 0x48, 0x60, 0x90, 0x102, 0x108, 0x201, 0x204, 0x480, 0x1020 };
const uint32_t boards3[] = { 0x26, 0x16, 0x19, 0x46, 0x49, 0x52, 0x58, 0x61, 0x64, 0x91, 0x94, 0x106, 0x109, 0x112, 0x148, 0x160, 0x190, 0x205, 0x211, 0x244, 0x250, 0x442, 0x448, 0x481, 0x484, 0x490, 0x580, 0x640, 0x1012, 0x1018, 0x1021, 0x1024, 0x1060, 0x1120, 0x1210, 0x1402, 0x1408, 0x1801, 0x2404 };
const uint32_t boards4[] = { 0x6C, 0x5A, 0x66, 0x69, 0x96, 0x99, 0xA5, 0x11A, 0x126, 0x14A, 0x162, 0x168, 0x189, 0x192, 0x198, 0x1A1, 0x1A4, 0x216, 0x219, 0x246, 0x249, 0x252, 0x258, 0x261, 0x264, 0x291, 0x294, 0x44A, 0x462, 0x486, 0x489, 0x492, 0x498, 0x4A1, 0x4A4, 0x582, 0x588, 0x5A0, 0x642, 0x648, 0x681, 0x684, 0x690, 0x885, 0x891, 0x981, 0x984, 0x101A, 0x1026, 0x1029, 0x1062, 0x1068, 0x1098, 0x10A1, 0x10A4, 0x1122, 0x1128, 0x11A0, 0x1212, 0x1218, 0x1221, 0x1224, 0x1260, 0x140A, 0x1422, 0x1428, 0x1482, 0x1488, 0x14A0, 0x1602, 0x1608, 0x1806, 0x1809, 0x1812, 0x1818, 0x1821, 0x1842, 0x1848, 0x1860, 0x1881, 0x1884, 0x1890, 0x1902, 0x1908, 0x1A01, 0x2025, 0x2064, 0x2121, 0x2124, 0x2406, 0x2409, 0x2412, 0x2418, 0x2421, 0x2424, 0x2442, 0x2448, 0x2460, 0x2484, 0x2502, 0x2508, 0x2604, 0x2805, 0x2811, 0x2844, 0x4488, 0x4884, 0x11022, 0x12021 };
const uint32_t boards5[] = { 0x99, 0x15A, 0x166, 0x169, 0x196, 0x199, 0x1A5, 0x256, 0x259, 0x265, 0x45A, 0x466, 0x496, 0x499, 0x4A5, 0x586, 0x589, 0x592, 0x598, 0x5A1, 0x5A4, 0x646, 0x649, 0x652, 0x685, 0x691, 0x694, 0x985, 0x991, 0x105A, 0x1066, 0x1099, 0x10A5, 0x1126, 0x1129, 0x1162, 0x1168, 0x11A1, 0x11A4, 0x1216, 0x1219, 0x1225, 0x1258, 0x1264, 0x141A, 0x1426, 0x1429, 0x144A, 0x1462, 0x1468, 0x1486, 0x1489, 0x1492, 0x1498, 0x14A1, 0x14A4, 0x150A, 0x1522, 0x1528, 0x1582, 0x1588, 0x15A0, 0x1606, 0x1609, 0x1612, 0x1618, 0x1621, 0x1624, 0x1642, 0x1648, 0x1660, 0x1681, 0x1684, 0x1690, 0x1816, 0x1819, 0x1825, 0x1846, 0x1852, 0x1858, 0x1864, 0x1885, 0x1891, 0x1894, 0x1906, 0x1909, 0x1921, 0x1942, 0x1948, 0x1960, 0x1981, 0x1984, 0x1A05, 0x1A11, 0x1A44, 0x2065, 0x2125, 0x2164, 0x2416, 0x2419, 0x2425, 0x2446, 0x2449, 0x2452, 0x2458, 0x2461, 0x2464, 0x2485, 0x2491, 0x2494, 0x2506, 0x2509, 0x2512, 0x2518, 0x2521, 0x2524, 0x2584, 0x2605, 0x2611, 0x2614, 0x2644, 0x2845, 0x2851, 0x2854, 0x2905, 0x2911, 0x2944, 0x444A, 0x4462, 0x4489, 0x4492, 0x4498, 0x44A1, 0x44A4, 0x4588, 0x4648, 0x4885, 0x4891, 0x5422, 0x5806, 0x5809, 0x5812, 0x5821, 0x5848, 0x6421, 0x6811, 0x9811, 0x1101A, 0x11026, 0x11062, 0x110A1, 0x11122, 0x11212, 0x12025 };
const uint32_t boards6[] = { 0xB7, 0x59A, 0x5A6, 0x5A9, 0x65A, 0x666, 0x696, 0x699, 0x6A5, 0x996, 0x999, 0x11A6, 0x11A9, 0x125A, 0x1266, 0x1299, 0x12A5, 0x149A, 0x14A6, 0x14A9, 0x158A, 0x15A2, 0x15A8, 0x161A, 0x1626, 0x1629, 0x164A, 0x1662, 0x1668, 0x1686, 0x1689, 0x1692, 0x1698, 0x16A1, 0x16A4, 0x185A, 0x1866, 0x1896, 0x1899, 0x18A5, 0x1926, 0x1929, 0x194A, 0x1962, 0x1968, 0x1986, 0x1989, 0x19A1, 0x19A4, 0x1A16, 0x1A19, 0x1A25, 0x1A46, 0x1A52, 0x1A58, 0x1A64, 0x2166, 0x2169, 0x245A, 0x2466, 0x2469, 0x2499, 0x24A5, 0x251A, 0x2526, 0x2529, 0x2589, 0x2598, 0x25A1, 0x25A4, 0x2616, 0x2619, 0x2646, 0x2649, 0x2652, 0x2658, 0x2685, 0x2691, 0x2694, 0x2856, 0x2859, 0x2865, 0x2916, 0x2919, 0x2925, 0x2946, 0x2949, 0x2952, 0x2958, 0x2961, 0x2964, 0x2985, 0x2991, 0x2994, 0x2A45, 0x2A51, 0x2A54, 0x449A, 0x44A6, 0x44A9, 0x458A, 0x45A2, 0x45A8, 0x464A, 0x4662, 0x4689, 0x4692, 0x4698, 0x46A1, 0x46A4, 0x4896, 0x4899, 0x4989, 0x4992, 0x54A2, 0x54A8, 0x5622, 0x581A, 0x5826, 0x5829, 0x584A, 0x5862, 0x5868, 0x5886, 0x5889, 0x5892, 0x5898, 0x58A1, 0x58A4, 0x590A, 0x5922, 0x5988, 0x5A06, 0x5A09, 0x5A12, 0x5A21, 0x5A48, 0x6426, 0x6429, 0x6468, 0x6522, 0x6816, 0x6819, 0x6825, 0x6846, 0x6849, 0x6852, 0x6858, 0x6861, 0x6891, 0x6909, 0x6912, 0x6921, 0x6948, 0x6A11, 0x8991, 0x9816, 0x9819, 0x9825, 0x9921, 0x9A11, 0x1109A, 0x110A6, 0x110A9, 0x111A2, 0x1121A, 0x11226, 0x11262, 0x112A1, 0x114A2, 0x11892, 0x12066, 0x12069, 0x12126, 0x12426, 0x12429, 0x12462, 0x124A1, 0x12522, 0x12816, 0x12819, 0x12852, 0x12912, 0x16422 };
const uint32_t boards7[] = { 0x5F, 0x15A6, 0x15A9, 0x165A, 0x1666, 0x1696, 0x1699, 0x16A5, 0x1966, 0x19A5, 0x1A56, 0x2599, 0x25A5, 0x2656, 0x2659, 0x2956, 0x2959, 0x2965, 0x459A, 0x45A9, 0x465A, 0x4666, 0x4696, 0x4699, 0x46A5, 0x4999, 0x549A, 0x54A6, 0x54A9, 0x55A2, 0x55A8, 0x561A, 0x5626, 0x5629, 0x5662, 0x5668, 0x5698, 0x56A1, 0x56A4, 0x585A, 0x5866, 0x5896, 0x5899, 0x58A5, 0x5929, 0x594A, 0x5962, 0x5968, 0x5989, 0x59A1, 0x5A16, 0x5A19, 0x5A25, 0x5A46, 0x5A52, 0x5A58, 0x6466, 0x6469, 0x6529, 0x6856, 0x6859, 0x6865, 0x6919, 0x6949, 0x6952, 0x6958, 0x6961, 0x6991, 0x6A51, 0x9856, 0x9925, 0x111A6, 0x1125A, 0x11266, 0x11299, 0x112A5, 0x114A6, 0x114A9, 0x115A2, 0x11662, 0x116A1, 0x11896, 0x11899, 0x12166, 0x12466, 0x12469, 0x124A5, 0x12526, 0x12856, 0x12859, 0x12865, 0x12916, 0x12952, 0x16426, 0x16522, 0x16816 };
const uint32_t * const boards[] = { boards0, boards1, boards2, boards3, boards4, boards5, boards6, boards7 };

//#define TEST_MEM
#ifdef TEST_MEM
#define BYTES 930 //1119
uint8_t moves0[BYTES];
const uint8_t * const moves[] = { moves0 };
#else
// move weighting arrays, split into even and odd moves for whether the system
// is moving first or the player
// couldn't fit all into RAM at once by ~200 bytes
#ifdef MOVES_EVEN
uint8_t moves0[] = { 0x77, 0x77, 0x77, 0x77, 0x70 };
uint8_t moves2[] = { 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70, 0x77, 0x77, 0x77, 0x70 };
uint8_t moves4[] = { 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70, 0x77, 0x77, 0x70 };
uint8_t moves6[] = { 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70, 0x77, 0x70 };
#else
uint8_t moves0[1];
uint8_t moves2[1];
uint8_t moves4[1];
uint8_t moves6[1];
#endif
#ifdef MOVES_ODD
uint8_t moves1[] = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 };
uint8_t moves3[] = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 };
uint8_t moves5[] = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 };
uint8_t moves7[] = { 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77 };
#else
uint8_t moves1[1];
uint8_t moves3[1];
uint8_t moves5[1];
uint8_t moves7[1];
#endif
uint8_t * const moves[] = { moves0, moves1, moves2, moves3, moves4, moves5, moves6, moves7 };
#endif

//#define USE_RAND_FUN
#ifndef USE_RAND_FUN
// random uint8_t's used to 'generate' randomness, generated by gen_bytes.py
const uint8_t randNums[] = { 0x91, 0x5E, 0x62, 0xF4, 0xBF, 0xFC, 0x50, 0xB2, 0xC2, 0x7, 0xBE, 0x7D, 0xE2, 0xE4, 0xD5, 0x14, 0x6D, 0x52, 0x62, 0x62, 0xF4, 0xB5, 0xE6, 0x64, 0x76, 0x85, 0x4A, 0x56, 0xC7, 0xCC, 0xFA, 0xAD, 0xA, 0x35, 0x8C, 0x5C, 0xA4, 0x2C, 0xFF, 0xE9, 0x11, 0x9E, 0x5A, 0xE, 0xD, 0x43, 0x50, 0x25, 0x53, 0x47, 0x67, 0xC, 0x7D, 0x1A, 0x35, 0x81, 0x24, 0xE, 0x7E, 0x70, 0xF2, 0x6F, 0x90, 0x86, 0xBB, 0xF2, 0x45, 0x6C, 0xF9, 0xEB, 0xDC, 0xF4, 0x9, 0xC5, 0x72, 0x2B, 0x6A, 0xF7, 0x11, 0x84, 0xFB, 0x7, 0x8E, 0x3, 0xEC, 0x64, 0x4D, 0x5D, 0xC8, 0x82, 0xEE, 0x80, 0xC2, 0x72, 0xBE, 0x9E, 0x9F, 0xD8, 0xC6, 0xD6, 0x32, 0xF7, 0x88, 0x3D, 0xBF, 0xE0, 0x93, 0xBB, 0x5A, 0xE6, 0xF3, 0xF6, 0x87, 0x3B, 0x9C, 0x0, 0x40, 0xB4, 0xDA, 0x8E, 0x1C, 0xA5, 0x7B, 0x54, 0x45, 0xD8, 0x7 };
const uint32_t randLen = 127;
#endif

// permutations of a board that are equivalent
const uint8_t permute0[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };
// rotate right 90
const uint8_t permute1[] = { 2, 5, 8, 1, 4, 7, 0, 3, 6 };
// rotate right 180
const uint8_t permute2[] = { 8, 7, 6, 5, 4, 3, 2, 1, 0 };
// rotate right 270
const uint8_t permute3[] = { 6, 3, 0, 7, 4, 1, 8, 5, 2 };
// flip horizontal
const uint8_t permute4[] = { 2, 1, 0, 5, 4, 3, 8, 7, 6 };
// flip vertical
const uint8_t permute5[] = { 6, 7, 8, 3, 4, 5, 0, 1, 2 };
// flip diagonal bottom-left to top-right
const uint8_t permute6[] = { 8, 5, 2, 7, 4, 1, 6, 3, 0 };
// flip diagonal top-left to bottom-right
const uint8_t permute7[] = { 0, 3, 6, 1, 4, 7, 2, 5, 8 };
const uint8_t * const permute[] = { permute0, permute1, permute2, permute3, permute4, permute5, permute6, permute7 };


// main 
void tttMain(void)
{
    // initialize display
    devSSD1331Init();

    // draw a sample board
    drawGrid();
    drawCross(0, true);
    drawCross(2, true);
    drawCross(4, true);
    drawCross(6, true);
    drawCross(8, true);
    drawNought(1, false);
    drawNought(3, false);
    drawNought(5, false);
    drawNought(7, false);

    // main state loop
    while (1)
    {
        uint8_t key = 0;
        // read input key
        if (SEGGER_RTT_HasKey())
        {
            key = SEGGER_RTT_GetKey();
        }
        else if ((state == IDLE || state == PLAY) && keypadGetKey(&key))
        {
            
        }
        else
        {
            OSA_TimeDelay(1);
            continue;
        }
        
        // to uppercase
        if (key > 96)
            key -= 32;

        // reset key
        if (key == 'R')
            state = IDLE;

        switch (state)
        {
            case IDLE:
                switch (key)
                {
                    // play mode, plays once then goes back to idle
                    case 'P':
                        state = PLAY;
                        resetGame();
                        clearBoard();
#ifdef ME_FIRST
                        // system move first
                        move(true, key, PLAY_LEARN, true);
                        if (numMove > 8)
                        {
                            state = IDLE;
                            break;
                        }
#endif
                        break;
                    // train mode, learns whilst playing
                    case 'T':
                        state = TRAIN;
                        resetGame();
                        clearBoard();
#ifdef ME_FIRST
                        move(true, key, true, true);
                        if (numMove > 8)
                        {
                            state = IDLE;
                            break;
                        }
#endif
                        break;
                    // fast-train mode, doesn't draw to display
                    case 'F':
                        state = TRAIN_FAST;
                        resetGame();
#ifdef ME_FIRST
                        move(true, key, true, false);
                        if (numMove > 8)
                        {
                            state = IDLE;
                            break;
                        }
#endif
                        break;
                }
                break;
            case PLAY:
            case TRAIN:
            case TRAIN_FAST:
                // player move
                if (move(false, key, ((state != PLAY) || PLAY_LEARN), (state != TRAIN_FAST)))
                {
                    // check whether game is over
                    if (numMove > 8)
                    {
                        state = IDLE;
                        break;
                    }
                    // system move
                    move(true, key, ((state != PLAY) || PLAY_LEARN), (state != TRAIN_FAST));
                    if (numMove > 8)
                    {
                        state = IDLE;
                        break;
                    }
                }
                break;
            default:
                state = IDLE;
                break;
        }
    }
}


// read a key from an attached keypad (todo)
bool keypadGetKey(uint8_t *key)
{
    return false;
}


// make a move for a player
bool move(const bool me, const char key, const bool learn, const bool draw)
{
    const bool cross = me;
    uint8_t box;

    // move
    if (me)
    {
        box = pickBox();
        // check if pick failed
        if (box > 8)
        {
            SEGGER_RTT_WriteString(0, "E\n");
            numMove = 9;
            return true;
        }

        // add to game array
        if (cross)
            game[numMove] = BOX_CROSS_MASK | BOX_MINE_MASK | box;
        else
            game[numMove] = BOX_MINE_MASK | box;
        numMove++;

        // print to player
        SEGGER_RTT_PutChar(0, box + '0');
        SEGGER_RTT_PutChar(0, '\n');

        // draw on display and over RTT
        if (draw)
        {
            if (cross)
                drawCross(box, true);
            else
                drawNought(box, true);
            printBoard();
        }
    }
    else
    {
        // check key is in correct range
        if (key < '0' || key > '9')
        {
            // if not, flash the board error
            if (draw)
            {
                drawError(0xFF);
                OSA_TimeDelay(ERROR_FLASH_MS);
                clearBoard();
                drawBoard();
            }
            // return to get another key
            return false;
        }
        // convert to int
        box = key - '0';
        // check box is empty
        for (uint8_t i = 0; i < numMove; i++)
        {
            if ((game[i] & BOX_NUM_MASK) == box)
            {
                // if not, flash box error
                if (draw)
                {
                    drawError(box);
                    OSA_TimeDelay(ERROR_FLASH_MS);
                    clearBoard();
                    drawBoard();
                }
                return false;
            }
        }

        // add to game array
        if (cross)
            game[numMove] = BOX_CROSS_MASK | box;
        else
            game[numMove] = box;
        numMove++;

        // draw on display and over RTT
        if (draw)
        {
            if (cross)
                drawCross(box, false);
            else
                drawNought(box, false);
            SEGGER_RTT_PutChar(0, '\n');
            printBoard();
        }
    }

    if (numMove >= 5)
    {
        // check for win
        bool win = false;

        const uint8_t boxRow = box / 3;
        const uint8_t boxCol = box % 3;
        // row
        if (checkWin(3*boxRow, 3*boxRow + 1, 3*boxRow + 2, cross))
        {
            if (draw)
                drawWin(3*boxRow, 3*boxRow + 2, me);
            win = true;
        }
        // column
        else if (checkWin(boxCol, boxCol + 3, boxCol + 6, cross))
        {
            if (draw)
                drawWin(boxCol, boxCol + 6, me);
            win = true;
        }
        // diagonal
        else if (checkWin(0, 4, 8, cross))
        {
            if (draw)
                drawWin(0, 8, me);
            win = true;
        }
        // diagonal
        else if (checkWin(2, 4, 6, cross))
        {
            if (draw)
                drawWin(2, 6, me);
            win = true;
        }
        
        // if someone has won...
        if (win)
        {
            // print win/loss
            if (me)
                SEGGER_RTT_PutChar(0, 'W');
            else
                SEGGER_RTT_PutChar(0, 'L');
            SEGGER_RTT_PutChar(0, '\n');
            // learn from it
            if (learn)
                learnFrom(me);
            // end game
            numMove = 9;
        }
        // check for draw
        else if (numMove > 8)
        {
            SEGGER_RTT_WriteString(0, "D\n");
        }
    }

    return true;
}


// check three boxes for a win
bool checkWin(uint8_t box0, uint8_t box1, uint8_t box2, bool cross)
{
    uint8_t n = 0;
    for (uint8_t i = 0; i < numMove; i++)
    {
        if (((bool)(game[i] & BOX_CROSS_MASK) == cross) &&
            (((game[i] & BOX_NUM_MASK) == box0) ||
             ((game[i] & BOX_NUM_MASK) == box1) ||
             ((game[i] & BOX_NUM_MASK) == box2)))
        {
            n++;
        }
    }

    return (n >= 3);
}


// reset game
void resetGame(void)
{
    for (uint8_t i = 0; i < numMove; i++)
        game[i] = 0;
    numMove = 0;
}


// clear the board on the display
void clearBoard(void)
{
    devSSD1331Clear(&(const screenCoord){32, 0}, &(const screenCoord){95, 63});
    drawGrid();
}


// draw the board on the display
void drawBoard(void)
{
    for (uint8_t i = 0; i < numMove; i++)
    {
        switch (game[i] & BOX_STAT_MASK)
        {
            case BOX_CROSS_MASK:
            case BOX_CROSS_MASK | BOX_MINE_MASK:
                drawCross(game[i] & BOX_NUM_MASK, game[i] & BOX_MINE_MASK);
                break;
            case 0:
            case BOX_MINE_MASK:
                drawNought(game[i] & BOX_NUM_MASK, game[i] & BOX_MINE_MASK);
                break;
        }
    }
}


// print the board over RTT
void printBoard(void)
{
    for (uint8_t i = 0; i < 3; i++)
    {
        for (uint8_t j = 0; j < 3; j++)
        {
            char c = ' ';
            uint8_t k = 0;
            for (; k < numMove; k++)
            {
                if ((game[k] & BOX_NUM_MASK) == 3*i + j)
                    break;
            }
            if (k < numMove)
            {
                switch (game[k] & BOX_STAT_MASK)
                {
                    case BOX_CROSS_MASK:
                    case BOX_CROSS_MASK | BOX_MINE_MASK:
                        c = 'X';
                        break;
                    case 0:
                    case BOX_MINE_MASK:
                        c = 'O';
                        break;
                    default:
                        c = 'E';
                        break;
                }
            }
            SEGGER_RTT_PutChar(0, ' ');
            SEGGER_RTT_PutChar(0, c);
            SEGGER_RTT_PutChar(0, ' ');
            if (j < 2)
                SEGGER_RTT_WriteString(0, "|");
        }
        OSA_TimeDelay(PRINT_LINE_DELAY);
        if (i < 2)
        {
            SEGGER_RTT_WriteString(0, "\n-----------");
            OSA_TimeDelay(PRINT_LINE_DELAY);
        }
        SEGGER_RTT_PutChar(0, '\n');
    }
}


// draw the board grid on the display
void drawGrid(void)
{
    devSSD1331DrawRect(&(const screenCoord){95, 20}, &(const screenCoord){32, 21}, &COLOR_GRID, true);
    devSSD1331DrawRect(&(const screenCoord){95, 42}, &(const screenCoord){32, 43}, &COLOR_GRID, true);
    devSSD1331DrawRect(&(const screenCoord){74, 00}, &(const screenCoord){75, 63}, &COLOR_GRID, true);
    devSSD1331DrawRect(&(const screenCoord){52, 00}, &(const screenCoord){53, 63}, &COLOR_GRID, true);
}


// draw a cross on the display
void drawCross(const uint8_t box, const bool mine)
{
    screenColor color;
    if (mine)
        color = COLOR_ME;
    else
        color = COLOR_OPP;
    
    const uint8_t boxX = 95 - (box / 3) * 22;
    const uint8_t boxY = (box % 3) * 22;

    devSSD1331DrawLine(&(screenCoord){boxX - BOX_BORDER_OFFSET, boxY + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - 19 + BOX_BORDER_OFFSET, boxY + 19 - BOX_BORDER_OFFSET},
                       &color);
    devSSD1331DrawLine(&(screenCoord){boxX - 1 - BOX_BORDER_OFFSET, boxY + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - 19 + BOX_BORDER_OFFSET, boxY + 18 - BOX_BORDER_OFFSET},
                       &color);
    devSSD1331DrawLine(&(screenCoord){boxX - BOX_BORDER_OFFSET, boxY + 1 + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - 18 + BOX_BORDER_OFFSET, boxY + 19 - BOX_BORDER_OFFSET},
                       &color);

    devSSD1331DrawLine(&(screenCoord){boxX - 19 + BOX_BORDER_OFFSET, boxY + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - BOX_BORDER_OFFSET, boxY + 19 - BOX_BORDER_OFFSET},
                       &color);
    devSSD1331DrawLine(&(screenCoord){boxX - 19 + BOX_BORDER_OFFSET, boxY + 1 + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - 1 - BOX_BORDER_OFFSET, boxY + 19 - BOX_BORDER_OFFSET},
                       &color);
    devSSD1331DrawLine(&(screenCoord){boxX - 18 + BOX_BORDER_OFFSET, boxY + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - BOX_BORDER_OFFSET, boxY + 18 - BOX_BORDER_OFFSET},
                       &color);
}


// draw a nought on the display
void drawNought(const uint8_t box, const bool mine)
{
    screenColor color;
    if (mine)
        color = COLOR_ME;
    else
        color = COLOR_OPP;
    
    const uint8_t boxX = 95 - (box / 3) * 22;
    const uint8_t boxY = (box % 3) * 22;

    devSSD1331DrawRect(&(screenCoord){boxX - 19 + BOX_BORDER_OFFSET, boxY + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - BOX_BORDER_OFFSET, boxY + 19 - BOX_BORDER_OFFSET},
                       &color, false);
    devSSD1331DrawRect(&(screenCoord){boxX - 18 + BOX_BORDER_OFFSET, boxY + 1 + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - 1 - BOX_BORDER_OFFSET, boxY + 18 - BOX_BORDER_OFFSET},
                       &color, false);
    devSSD1331DrawRect(&(screenCoord){boxX - 17 + BOX_BORDER_OFFSET, boxY + 2 + BOX_BORDER_OFFSET},
                       &(screenCoord){boxX - 2 - BOX_BORDER_OFFSET, boxY + 17 - BOX_BORDER_OFFSET},
                       &color, false);
}


// draw a win line on the display between the two extremal boxes
void drawWin(const uint8_t box1, const uint8_t box2, const bool mine)
{
    screenColor color;
    if (mine)
        color = COLOR_ME;
    else
        color = COLOR_OPP;
    
    const uint8_t box1_x = 95 - (box1 / 3) * 22;
    const uint8_t box1_y = (box1 % 3) * 22;
    const uint8_t box2_x = 95 - (box2 / 3) * 22;
    const uint8_t box2_y = (box2 % 3) * 22;

    devSSD1331DrawLine(&(screenCoord){box1_x - 10, box1_y + 10},
                       &(screenCoord){box2_x - 10, box2_y + 10},
                       &color);
}


// fill in a box to signify and error
void drawError(const uint8_t box)
{
    if (box < 9)
    {
        const uint8_t boxX = 95 - (box / 3) * 22;
        const uint8_t boxY = (box % 3) * 22;
        devSSD1331DrawRect(&(screenCoord){boxX - 19, boxY},
                           &(screenCoord){boxX, boxY + 19},
                           &COLOR_ERR, true);
    }
    else
    {
        devSSD1331DrawRect(&(const screenCoord){32, 0}, &(const screenCoord){95, 63}, &COLOR_ERR, true);
    }
}


// select a box for a move
uint8_t pickBox(void)
{
    uint8_t box = 0;

    // if there's only one box left find it
    if (numMove > 7)
    {
        bool done = false;
        while (!done)
        {
            for (uint8_t i = 0; i < numMove; i++)
            {
                if ((game[i] & BOX_NUM_MASK) == box)
                {
                    box++;
                    break;
                }
                if (i == (numMove - 1))
                    done = true;
            }
        }
        return box;
    }
    
    // calculate the board ID
    uint32_t boardID;
    const uint8_t permutation = getMinBoardID(&boardID);
    // number of boards with current number of moves
    const uint32_t numBoards = boards[numMove][0];
    
    // search boards array for the index of the board ID
    int32_t lower = 0;
    int32_t higher = numBoards - 1;
    int32_t index = (lower + higher) / 2;
    uint32_t foundID = boards[numMove][index + 1];
    while (foundID != boardID)
    {
        // if not in the array something has gone wrong, return error
        if (lower >= higher)
            return 0xFF;
        if (foundID < boardID)
            lower = index + 1;
        else if (foundID > boardID)
            higher = index - 1;
        index = (lower + higher) / 2;
        foundID = boards[numMove][index + 1];
    }

    // calculate offset in moves array of the weightings for this board
    const uint8_t spaces = 9 - numMove;
    const uint32_t offset = ((spaces + 1) / 2) * index; 

    // get random uint8_t
#ifdef USE_RAND_FUN
    uint8_t randNum = (uint8_t)rand();
#else
    static uint32_t randIndex = 0;
    uint8_t randNum = randNums[randIndex];
    randIndex++;
    if (randIndex >= randLen)
        randIndex = 0;
#endif
    
    // calculate index of space to choose
    uint8_t spaceIndex = 0xFF;
    uint8_t i = 0;
    while (spaceIndex == 0xFF)
    {
        for (; i < spaces; i++)
        {
            uint8_t boxWeight = moves[numMove][offset + i/2];
            // weighting is in high nibble
            if (i % 2)
            {
#ifdef TEST_MEM
                spaceIndex = 0;
#endif
                boxWeight >> 4;
            }
            // low nibble
            else
            {
                boxWeight & 0x0F;
            }
            // this is the winning space
            if (randNum < boxWeight)
            {
                spaceIndex = i;
                break;
            }
            else
            {
                randNum -= boxWeight;
            }
        }
    }

    // store winning offset to increment/decrement on win/loss
    movesMade[numMove/2] = ((offset + i/2) << 1) + (i % 2);

    // calculate which box represents the space
    // i.e. if space = 3 then the box will be the 4th empty box
    // board is numbered left to right, top to bottom
    bool board[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    for (uint8_t i = 0; i < numMove; i++)
        board[(game[i] & BOX_NUM_MASK)] = true;
    for (uint8_t i = 0; i < 9; i++)
    {
        if (!board[permute[permutation][i]])
        {
            if (spaceIndex == 0)
            {
                box = permute[permutation][i];
                break;
            }
            else
            {
                spaceIndex--;
            }
        }
    }

    return box;
}


// calculate the minimum board ID of this board and its equivalents
// returns the permutation of the minimum
uint8_t getMinBoardID(uint32_t *boardID)
{
    // fill board array with 1s for first player moves, 2s for second
    // board is numbered left to right, top to bottom
    uint8_t board[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    uint8_t i = 0;
    for (; i < numMove; i++)
        board[(game[i] & BOX_NUM_MASK)] = (i % 2) + 1;

    // find minimum ID among equivalent boards
    uint32_t minBoardID = (uint32_t)(-1);
    for (uint8_t i = 0; i < 8; i++)
        minBoardID = min(minBoardID, getBoardID(board, permute[i]));

    *boardID = minBoardID;
    return i;
}


// calculate board ID for a permutation of a board
uint32_t getBoardID(const uint8_t *board, const uint8_t *permute)
{
    // shift number in each box according to box position and sum
    uint32_t boardID = 0;
    for (uint8_t i = 0; i < 9; i++)
        boardID |= (uint32_t)board[i] << (2 * permute[i]);
    return boardID;
}


// learn from game
void learnFrom(const bool won)
{
#ifdef ME_FIRST
    uint8_t moveNum = 0;
#else
    uint8_t moveNum = 1;
#endif
    // for each move the system made...
    for (; (moveNum < numMove) && (moveNum < 8); moveNum += 2)
    {
        // retrieve the stored offset into moves array
        uint8_t *address = &(moves[moveNum][movesMade[moveNum/2] >> 1]);
        // whether we are changing the high or low nibble
        const bool highNibble = movesMade[moveNum/2] & 1;
        if (highNibble)
        {
            // get current weighting
            const uint8_t boxWeight = *address >> 4;
            // check if an increment/decrement would be <16 and >1
            if (won && (boxWeight < (16 - LEARN_INC)))
                *address += LEARN_INC << 4;
            else if (boxWeight > LEARN_INC)
                *address -= LEARN_INC << 4;
        }
        else
        {
            const uint8_t boxWeight = *address & 0x0F;
            if (won && (boxWeight < (16 - LEARN_INC)))
                *address += LEARN_INC;
            else if (boxWeight > LEARN_INC)
                *address -= LEARN_INC;
        }
    }
}